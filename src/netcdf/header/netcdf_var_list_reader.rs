use std::io::{BufReader, Read, Seek};

use byteorder::{BigEndian, ReadBytesExt};

use crate::netcdf::common::netcdf_error::NetCdfError;
use crate::netcdf::header::netcdf_var::NetCdfVar;
use crate::netcdf::header::netcdf_var_reader::NetCdfVarReader;

pub struct NetCdfVarListReader;


impl NetCdfVarListReader {
    const NC_VARIABLE_TAG: u32 = 0x000B;

    pub fn read<T: Read + Seek>(reader: &mut BufReader<T>) -> Result<Vec<NetCdfVar>, NetCdfError> {
        let nc_attribute_tag = reader.read_u32::<BigEndian>()?;
        if nc_attribute_tag != Self::NC_VARIABLE_TAG {
            return Ok(vec![]);
        }

        let mut attributes: Vec<NetCdfVar> = vec![];
        let num_elements = reader.read_u32::<BigEndian>()?;
        for _ in 0..num_elements {
            let attr = NetCdfVarReader::read(reader)?;
            attributes.push(attr);
        }

        return Ok(attributes);
    }
}


#[cfg(test)]
mod tests {
    use std::io::{BufReader, Cursor, Seek};
    use crate::netcdf::common::netcdf_value_type::NetCdfValueType;

    use crate::netcdf::header::netcdf_var_list_reader::NetCdfVarListReader;

    #[test]
    fn it_correctly_parses_the_var_list() {
        let mut reader = BufReader::new(Cursor::new([
            0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x63, 0x6C, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x09, 0x6C, 0x6F, 0x6E, 0x67, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x6C,
            0x6F, 0x6E, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x00, 0x00, 0x00, 0x05, 0x75, 0x6E, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x72, 0x61, 0x64, 0x69,
            0x61, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0E,
            0x67, 0x72, 0x69, 0x64, 0x5F, 0x6C, 0x6F, 0x6E, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x0D, 0x63, 0x6C, 0x6F, 0x6E, 0x5F, 0x76, 0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x21, 0x28, 0x00, 0x00, 0x00, 0x04, 0x63, 0x6C, 0x61, 0x74, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09,
            0x6C, 0x6F, 0x6E, 0x67, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0F, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x6C, 0x61, 0x74, 0x69, 0x74,
            0x75, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x05, 0x75, 0x6E, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x72, 0x61, 0x64, 0x69, 0x61, 0x6E, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0D, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0D, 0x67, 0x72, 0x69, 0x64,
            0x5F, 0x6C, 0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0D,
            0x63, 0x6C, 0x61, 0x74, 0x5F, 0x76, 0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x68, 0x21, 0x28,
            0x00, 0x00, 0x00, 0x0D, 0x63, 0x6C, 0x6F, 0x6E, 0x5F, 0x76, 0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x75, 0x6E, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x72, 0x61, 0x64, 0x69,
            0x61, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xD0, 0x21, 0x28, 0x00, 0x00, 0x00, 0x0D, 0x63, 0x6C, 0x61, 0x74, 0x5F, 0x76, 0x65, 0x72,
            0x74, 0x69, 0x63, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05,
            0x75, 0x6E, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x72, 0x61, 0x64, 0x69, 0x61, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x38, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x21, 0x28, 0x00, 0x00, 0x00, 0x04, 0x76, 0x6C, 0x6F, 0x6E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04,
            0x00, 0x00, 0x00, 0x09, 0x6C, 0x6F, 0x6E, 0x67, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x20, 0x6C,
            0x6F, 0x6E, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x00, 0x00, 0x00, 0x05, 0x75, 0x6E, 0x69, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x72, 0x61, 0x64, 0x69,
            0x61, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0E,
            0x67, 0x72, 0x69, 0x64, 0x5F, 0x6C, 0x6F, 0x6E, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x0D, 0x76, 0x6C, 0x6F, 0x6E, 0x5F, 0x76, 0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xB4, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
            0x0B, 0x40, 0x21, 0x28
        ]));

        let result = NetCdfVarListReader::read(&mut reader);
        assert!(result.is_ok());

        let var_list = result.unwrap();
        assert_eq!(5, var_list.len());

        assert_eq!("clon", var_list[0].name);
        assert_eq!(NetCdfValueType::NcDouble, var_list[0].nc_type);
        assert_eq!(23592960, var_list[0].size);
        assert_eq!(8488, var_list[0].begin);
        assert_eq!("clat", var_list[1].name);
        assert_eq!(NetCdfValueType::NcDouble, var_list[1].nc_type);
        assert_eq!(23592960, var_list[1].size);
        assert_eq!(23601448, var_list[1].begin);
        assert_eq!("clon_vertices", var_list[2].name);
        assert_eq!(NetCdfValueType::NcDouble, var_list[2].nc_type);
        assert_eq!(70778880, var_list[2].size);
        assert_eq!(47194408, var_list[2].begin);
        assert_eq!("clat_vertices", var_list[3].name);
        assert_eq!(NetCdfValueType::NcDouble, var_list[3].nc_type);
        assert_eq!(70778880, var_list[3].size);
        assert_eq!(117973288, var_list[3].begin);
        assert_eq!("vlon", var_list[4].name);
        assert_eq!(NetCdfValueType::NcDouble, var_list[4].nc_type);
        assert_eq!(11796496, var_list[4].size);
        assert_eq!(188752168, var_list[4].begin);

        assert_eq!(740 as u64, reader.stream_position().unwrap())
    }


    #[test]
    fn it_correctly_parses_an_absent_var_list() {
        let mut reader = BufReader::new(Cursor::new([
            0x00, 0x00, 0x00, 0x00
        ]));

        let result = NetCdfVarListReader::read(&mut reader);
        assert!(result.is_ok());

        let var_list = result.unwrap();
        assert_eq!(0, var_list.len());

        assert_eq!(4 as u64, reader.stream_position().unwrap())
    }
}
